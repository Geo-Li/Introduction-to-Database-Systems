Writeup for Lab3

There aren't too many special design decisions I made for this lab, but if I had to describe this, I would describe how I designed the operators.
The Filter is rather simple; for Join, the decisions I made are: 1. combine TupleDesc by looping through TupleDesc for Tuple1 and Tuple2, 2. fetchnext by using a nested loop, namely, if we have a tuple from child1 is in use, then we loop through child2 one at a time to return the joined tuple; for the Aggregate operator, I designed how open should work. Basically, I set up aggregators in the open method based on the aggregate type, for example, INT_TYPE or STRING_TYPE. Then, I loop through child tuples to merge them into the aggregator. Finally, I can just use the iterator from the aggregator to fetch the next return tuple for Aggregate; For Insert and Delete operators, I initially loop through everything in the open method to count how many tuples we handled, but I can't pass the system test in this case, so I moved everything to the fetchNext and created a boolean value to check if fetchNext has been called already, which prevents to throw an error when the child has no more tuple to read. 

Apart from the operators, how I implemented IntAggregator and StringAggregator is also worth mentioning. Because they follow the same pattern, I will describe how I implemented IntOperator here. First I introduced a helper class called AggregatorInfo to help me track information for sum, count, etc., then for the mergeTupleIntoGroup, I essentially decide whether we have a groupby field and then update the AggregatorInfo based on the tuple aggregate field values. (Of course, I have a map here to classify different values from the groupby field) Finally, for the iterator, I just need to form tuples based on operator types, for example, min, max, etc. For HeapPage, everything is intuitive as long as I set the right bit for the header while manipulating tuples. HeapFile is also very intuitive for handling tuples, which basically is to find the right HeapPage to insert or delete tuples. It is only when we running out of the page, we need to create a new one for BufferPool to use. For BufferPool, everything is intuitive besides I need to evictPage while we are running out of space when doing tuple insertion and deletion. The page eviction policy I had is rather simple, which is to find a clean page, in other words, pages that are not in use, then flush them to write new tuple data on it. 

For this lab, I didn't modify the API. 

Since I passed all the test cases provided, I assume there is nothing missing or incomplete in my code. 

I think I spent 5 days on this lab. The part I find confusing is that I need to evict the page while inserting or deleting tuples in the BufferPool. Also, it is not clear that I need to create another page while inserting tuples in HeapFile. Another confusion came from the error handling. Sometimes, I need to handle errors to pass the test but it is not mentioned in the instructions, sometimes I handle exceptions but there is no test to test on them. One example could be handling errors for deleteTuple in HeapPage. I mean there should be more confusion here, but I just can't recall.