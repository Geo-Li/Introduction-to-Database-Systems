For the deadlock handling, I tried to implement a dependency graph, which will detect if there is a cyclic, in other words, a deadlock, every time when new lock is acquired to the graph, and when there is a deadlock, then what my plan is to abort all the transactions that blocked the current transaction so it can run. However, owing to the time limitation, I didn't work this out, might try to figure it out when I have time over the winter break. The current implementation just uses a hard-coded time to try to assign locks to the same transaction multiple times, and if the blocked transaction is finished running, the current transaction can be assigned with a lock. For the dependency graph, this approach is better and more controllable because the system can detect and decide whether we need to abort other transactions for the current one, however, the dfs search algorithm along with the dependency graph generation is slow. On the other hand, the hard-coded timer is easier to implement and aborts the transaction when the other transactions are not finished, but obviously, this approach has the lowest controllability. 
For the API, I didn't make any changes.
I believe I implemented all the codes.
I spent four, or five days on this lab, and the most difficult part was to understand the concept and debug. It is not easy to get the idea of using a LockManager class. Initially, I understood that I needed to have two types of locks for each get page method, and I followed the instructions about all possible cases that we may assign locks to different pages, but write them down into codes, and choose which type to hold them requires a lot of thinking. After this part, the rest is not that tricky to me. The Transaction tests are hard to debug especially since we have threads and so many methods involved, and I spend days on debugging this. 
I don't know if the implementation of the dependency graph can be considered as extra credit, but I will try the dependency graph out myself later.